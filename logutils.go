package vulcan

import (
	"flag"
	"fmt"
	"github.com/golang/glog"
	"os"
	"path/filepath"
)

// Removes old logs generated by golang
func CleanupLogs() error {
	currentDir := LogDir()
	if currentDir == "" {
		glog.Infof("Glog's log dir is not set, nothing to clean up")
		return nil
	}
	glog.Infof("Will clean up logs in: %s", currentDir)
	return removeFiles(currentDir, programName())
}

// Shortcut to check if the path is actually a dir
func isDir(path string) (bool, error) {
	fi, err := os.Lstat(path)
	if err != nil {
		return false, err
	}
	return fi.IsDir(), nil
}

// Determines current program name as it's being used
// by golang to generate log file names
func programName() string {
	return filepath.Base(os.Args[0])
}

// Determines whether golang's log_dir has been set without overriding it
func LogDir() string {
	logDir := ""
	flag.Visit(func(f *flag.Flag) {
		if f.Name == "log_dir" {
			logDir = f.Value.String()
		}
	})
	return logDir
}

// Function that removes files in the logDir matching prefix
// It does not touch symlinks and the files that are being referenced
// by symlinks, it also skips directories
func removeFiles(logDir string, prefix string) error {
	pattern := fmt.Sprintf("%s/%s*", logDir, prefix)

	files, err := filepath.Glob(pattern)
	if err != nil {
		glog.Errorf("Failed to glob %s %s", pattern, err)
		return err
	} else {
		glog.Infof("Found files matching %s: %v", pattern, files)
	}

	toSkip := make(map[string]bool)
	for _, file := range files {
		dir, err := isDir(file)
		if err != nil {
			return err
		}
		if dir {
			toSkip[file] = true
		} else {
			realFile, err := filepath.EvalSymlinks(file)
			if err != nil {
				glog.Errorf("Failed to eval symlink %s", file, err)
				return err
			}
			if realFile != file {
				toSkip[file] = true
				toSkip[realFile] = true
			}
		}
	}

	for _, file := range files {
		if toSkip[file] {
			glog.Infof("Skipping file: %s", file)
		} else {
			glog.Infof("Removing: %s", file)
			err = os.Remove(file)
			if err != nil {
				glog.Errorf("Failed to remove %s: %s", file, err)
				return err
			}
		}
	}
	return nil
}
